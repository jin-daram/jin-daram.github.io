{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"이전 글 (NestJS 트랜잭션 적용 원리 알아보기) 에서는 NestJS와 Node.js 환경에서 TypeORM을 통해 어떤식으로  을 적용할 수 있는지 실제  코드와 함께 살펴봤다. 본 포스트에서는 typeorm-transactional을 사용하지 않고, 직접  Decorator를 구현하여 간편하게 트랜잭션을 적용하는 법을 보이겠다. Node.js의 T…","fields":{"slug":"/nestjs-tx-implement/"},"frontmatter":{"date":"June 12, 2025","title":"NestJS @Transactional 구현하기","tags":["Node.js","NestJS","트랜잭션","TypeORM"]},"rawMarkdownBody":"\n[이전 글 (NestJS 트랜잭션 적용 원리 알아보기)]() 에서는 NestJS와 Node.js 환경에서 TypeORM을 통해 어떤식으로 `Transaction` 을 적용할 수 있는지 실제 `TypeORM` 코드와 함께 살펴봤다.\n\n본 포스트에서는 [typeorm-transactional](https://www.npmjs.com/package/typeorm-transactional)을 사용하지 않고, 직접 `@Transactional` Decorator를 구현하여 간편하게 트랜잭션을 적용하는 법을 보이겠다.\n\n\n## Node.js의 Thread Local Storage\n\nThread Local Storage는 쉽게 말해서 각 Thread 마다 따로 저장되는 값이다. 멀티 스레드 환경에서 데이터 충돌을 방지하는 목적으로 사용하는 데 유용하다. \n\n```java\n/* Java에서 ThreadLocalStorage를 생성하고 사용하기 */\nThreadLocal<String> threadLocal = new ThreadLocal<>();\n\nthreadLocal.set(\"A\");\nString value = threadLocal.get(); // return \"A\"\n```\n\n다른 스레드에서는 `threadLocal` 변수에 저장된 `\"A\"` 라는 값을 조회할 수 없다.\n\n`Spring Boot`는 `멀티 스레드` 환경이기에 `ThreadPool` 에서 요청 하나 당 1개의 Thread를 할당 받아 처리하기 때문에 `ThreadLocal` 클래스를 통해 `ThreadLocalStorage` 를 사용할 수 있다.\n\n하지만 `Node.js` 환경은 `싱글 스레드 기반` 으로 동작하기 때문에 요청별 컨텍스트를 분리할 수 없어 기본적으로 Thread Local Storage를 만들 수 없다.\n\n### cls-hooked\n[cls-hooked](https://www.npmjs.com/package/cls-hooked) 는 `Node.js` 에서 `ThreadLocal` 처럼 동작하는 `Continuation-Local-Storage` 를 만들기 위해 나온 모듈이다. 이는 내부 `Namespace` 를 하나 생성하여, 내부적으로 `Map<asyncId, Context>` 구조로 저장소를 갖는다. \n\n하지만 마지막 업데이트가 너무 오래전이고, 비공식 구현체이다.\n\n\n### Async Local Storage\n`async_hooks` 기반으로 동작되는 공식 `Node.js` 의 `Async Local Storage` 이다. \n\n> **async_hooks 란?**\n> `async_hooks` 는 `Node.js` 에서 제공하는 비동기 콜백의 생명주기를 추적할 수 있는 API 이다. 싱글 스레드 기반인 Node.js 에서는 비동기 함수들의 흐름이 섞일 경우, 이를 추적하기 어렵다. 이를 쉽게하기 위해서 구현된 것이 `async_hooks` 이다.\n> 다만 이 `async_hook` 는 사용이 금지시 되고 있다. 비동기 컨텍스트 추적 용도로는 `AsyncLocalStorage` 를 사용하도록 권고되고 있다. [참고](https://nodejs.org/api/async_hooks.html?utm_source=chatgpt.com#async-hooks)\n\n`AsyncLocalStorage` 는 비동기 컨텍스트 유지가 가능하고, Node.js 에서 공식적으로 지원하는 비동기 컨텍스트 추적 객체이다. 다음과 같이 사용할 수 있다.\n\n```ts\n/* async-context.ts */\nimport { AsyncLocalStorage } from 'node:async_hooks';\n\nconst asyncLocalStorage = new AsyncLocalStorage<string>();\n\nexport const context = {\n  run: (value: string, callback: () => void) => {\n    asyncLocalStorage.run(value, callback);\n  },\n  get: (): string | undefined => {\n    return asyncLocalStorage.getStore();\n  },\n};\n```\n\n```ts\n/* runner.ts */\nimport { context } from './async-context';\n\ncontext.run('hello jin-daram', () => {\n  setTimeout(() => {\n    console.log(context.get());\n  }, 100);\n});\n```\n\n`Node.js` 기반 서버와 응용하여 사용하면 `Spring Boot` 의 `ThreadLocal` 처럼 활용할 수 있다.\n\n \n## @Transactional\n\n위에서, 알게 된 내용을 바탕으로 `@Transactional` Decorator를 생성하여 본다. 먼저 트랜잭션이 필요한 `Post` 요청을 처리하는 `Service`를 생성하도록 한다.\n\n```ts\n@Injectable()\nexport class UserService {\n\n  async createUser(userCreateRequest: UserCreateRequest): Promise<void> {\n    await this.userRepository.save(userCreateRequest);\n  }\n\n}\n```\n\n요청 정보로 `User` 를 생성하는 매우 간단한 코드이다. 지금은 `UserRepository` 생성 시 선언된 `EntityManager`를 통해 트랜잭션을 유지하기 때문에 `createUser()` 함수에 다른 엔티티에 대한 `INSERT`, `UPDATE`, `DELETE` 쿼리가 추가된다면 트랜잭션이 유지될 수 없는 상황이다.\n\n이제 `createUser()` 함수가 실행되기 전에 `em.transaction()` 콜백 함수의 인자로 들어오는 manager를 해당 요청 내에서 사용해야한다. 즉 `UserRepository` 에서 접근하는 `EntityManager` 가 변경되어야 하고, 이 접근 방식을 다르게 설정해야 한다. \n\n이는 `typeorm-transactional` 에서 구현했던 방식과 비슷하게 `Object.defineProperty(...)` 함수를 이용해서 설정한다.\n\n```ts\n/* init.ts */\nexport function init() {\n    Object.defineProperty(Repository.prototype, 'manager', {\n        configurable: true,\n        get() {\n            return context.get('entityManager')\n        },\n        set() {\n\n        }\n    })\n}\n```\n\n우리는 `CustomRepository` 를 만들 때, 반드시 `Repository<Entity extends ObjectLiteral>` 를 상속받아 사용한다. `Repository`의 `prototype`의 `manager` 라는 속성에 접근할 때, `Repository.manager` 에 접근하는 것이 아닌, 우리가 나중에 생성할 `Request Context` 에서 접근하도록 설정한다.\n\n```ts\n/* user.repository.ts */\nexport class UserRepository extends Repository<User> {\n  ...\n}\n```\n\n그리고 해당 함수를 `main.ts` 에서 App이 실행되기 전에 싫맹한다.\n```ts\n/* main.ts */\n\ninit()\n...\nbootstrap();\n\n```\n\n### Context 만들기\n`cls-hooked` 는 오래 전에 업데이트 되었기 때문에 상대적으로 최근에 생기고, `Node.js` 에서 지원하는 `Async-Local-Storage` 를 전격 활용하여 개발하도록 한다.\n\n```ts\n/* context.ts */\nexport class Context {\n\n    private dataSource: DataSource;\n    private readonly asyncLocalStorage = new AsyncLocalStorage<Map<string,EntityManager>>();\n\n    public getDataSource() {\n        return this.dataSource;\n    }\n\n    public async setDataSource(targetDataSource: DataSource) {\n        await targetDataSource.initialize();\n        this.dataSource = targetDataSource;\n    }\n\n    public run(store: Map<string, any>, callback: () => Promise<any>) {\n        return this.asyncLocalStorage.run(store, callback);\n    }\n\n    public get(key: string) {\n        return this.asyncLocalStorage.getStore()?.get(key);\n    }\n\n}\n```\n\n먼저 간단한 `Context` 클래스를 생성한다. 내부에는 `DataSource` 와 `AsyncLocalStorage` 로 이루어져 있다.\n \nDataSource는 `@Transactional` Decorator 에서 트랜잭션를 생성하기 위해 저장한다. 그렇기 때문에 `main.ts`에서 해당 `Context` 에 `DataSource` Mapping이 필요하다.\n\n```ts\ncontext.setDataSource(new DataSource({\n  type : \"postgres\",\n  host : \"localhost\",\n  port : 5433,\n  username: \"postgres\",\n  password : \"mypassword\",\n  database: \"postgres\",\n  entities: [User],\n  logging: true,\n}))\n\ninit()\n...\nbootstrap();\n```\n\n지금은 수동으로 `DataSource` 를 지정해주었지만, 향후 `TypeORM` 모듈을 통해 `Context` 에 자동으로 `DataSource` 를 설정하는 것도 가능할 것 같다.\n\n### @Transactional Decorator 생성하기\n```ts\nexport function Transactional(): MethodDecorator {\n  return function (_target, _propertyKey, descriptor: PropertyDescriptor) {\n    const original = descriptor.value;\n\n    descriptor.value = async function (...args: any[]) {\n      const dataSource = context.getDataSource();\n      return await dataSource.manager.transaction(async (transactionManager) => {\n        return await context.run(new Map([['entityManager', transactionManager]]), async () => {\n          return await original.apply(this, args);\n        });\n      });\n    };\n  };\n}\n```\n\n코드 구성은 간단하다. 전역적으로 접근할 수 있는 Context 로 부터, DataSource를 가져온다.\n\n그런 후에 DataSource의 EntityManager의 transaction() 함수를 통해 콜백 함수의 인자로 주어진 EntityManager를 `Map<string, EntityManager>` 형태의 Store에 저장한다.\n\n그리고 실행하고자 하는 함수를 실행한다.\n\n### 적용하기\n\n기존에 트랜잭션을 적용하고자 했던 함수에 `@Transactional` Decorator를 붙인다.\n\n```ts\n@Injectable()\nexport class UserService {\n\n  @Transactional\n  async createUser(userCreateRequest: UserCreateRequest): Promise<void> {\n    await this.userRepository.save(userCreateRequest);\n  }\n\n}\n```\n\n이후 결과를 확인해보면 성공적으로 트랜잭션이 원하는 대로 적용되는 것을 확인할 수 있다.\n\n![Transaction이 정상적으로 적용되는 모습](./transaction-success.png)\n\n\n자세한 코드는 [블로그 코드 Repository](https://github.com/jin-daram/tech-blog-code-lab) 에서 확인 할 수 있다.\n\n\n\n### References\n\nhttps://medium.com/%40sebcurland/the-power-of-async-hooks-in-node-js-8a2a84238acb\n"},{"excerpt":"Spring Boot 에서는 다음과 같은 코드로 간단하게  을 적용할 수 있다.  자세한 적용 원리나 옵션에 대해서는 의 @Transactional Annotation에 대해 학습이 필용하지만, 위 방법으로 단순하고 간단하게 을 적용할 수 있다. 이것이 가능하게 하는 것이 바로 AOP (Aspect-Oriented Programming, 관점 지향 프로그…","fields":{"slug":"/nestjs-tx-principle/"},"frontmatter":{"date":"June 05, 2025","title":"NestJS 트랜잭션 적용 원리 알아보기","tags":["Node.js","NestJS","트랜잭션","TypeORM"]},"rawMarkdownBody":"\n**Spring Boot** 에서는 다음과 같은 코드로 간단하게 `트랜잭션` 을 적용할 수 있다. \n\n```java\npublic class UserService {\n\n    private final UserRepository userRepository;\n    \n    @Transactional // 트랜잭션 적용\n    public void createUser(UserCreateRequest request) {\n        User user = userRepository.save(new User(...));\n    }\n}\n```\n\n자세한 적용 원리나 옵션에 대해서는 `Spring Boot`의 [@Transactional](https://docs.spring.io/spring-framework/reference/data-access/transaction/declarative/annotations.html) Annotation에 대해 학습이 필용하지만, 위 방법으로 단순하고 간단하게 `트랜잭션`을 적용할 수 있다.\n\n이것이 가능하게 하는 것이 바로 **AOP (Aspect-Oriented Programming, 관점 지향 프로그래밍, 이하 AOP)** 이다.\n\n## AOP?\n---\n> AOP 설명을 목적으로 하는 포스트는 아니기 때문에 단순하게 설명함으로 양해 부탁드립니다. 자세한 이론적인 내용은 [위키백과 - AOP](https://ko.wikipedia.org/wiki/%EA%B4%80%EC%A0%90_%EC%A7%80%ED%96%A5_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D) 를 참고 하길 바랍니다.\n\n쉽게 말하자면 `비즈니스 로직은  건들지 않고, 공통적으로 해야 하는 일을 앞, 뒤로 끼워넣는 프로그래밍 기법` 이다.\n<br>\n\n만약 프로젝트 내 모든 메소드의 실행 시간을 기록해야 한다면 어떨까?\n\n```java\npublic void login() {\n\tlong startTime = System.currentMillis();\n\t// 비즈니스 로직\n\tlog endTime = System.currentMillis();\n\tSystem.out.println(endTime - startTime + \"ms\")\n}\n```\n\n위 코드와 같은 포맷이 모든 메소드에 추가 되어야 할 것이다. 하지만 다음과 같이 구현한다면?\n\n```java\n@Measure\npublic void login() {\n\t// 비즈니스 로직\n}\n```\n\n단순히 `@Measure` 을 붙이는 것만으로 해결할 수 있다면 우리는 비즈니스 로직 앞 뒤에 아무것도 붙이지 않고, 깨끗하게 비즈니스 로직에만 집중 할 수 있다. 사실 메소드 소요 시간 측정은 정말 가벼운 기능이 추가되는 것이지만, 더 복잡한 로직이 생기게 된다면, 비즈니스 로직보다 공통 로직이 더 많은 부분을 차지하는 기이한 현상이 벌어질 수 있다.\n\n그렇기 때문에 Spring Boot 환경에서는 `@Transactional` Annotation을 통해 간단하게 `트랜잭션` 을 적용할 수 있는 방법을 제공한다.\n\n## Node.js 환경에서의 트랜잭션\n---\n트랜잭션은 Node.js 환경에서도 물론 필요하다. 그렇기 때문에 적용할 수 있어야 한다. 하지만 관심을 가지지 않으면 단독적으로 트랜잭션이 적용될 수 있다.\n\n```ts\n@Injectable()\nexport class UserService {\n\n\tconstructor(\n\t\tprivate readonly userRepository: UsreRepository,\n\t\tprivate readonly UserDetailRepository: UserDetailRepositoty\n\t)\t{}\n\n\tcreateUser(request: UserCreateRequest) {\n\t\tconst user = this.userRepository.save(request);\n\t\tconst userDetail = this.userDetailRepository.save(request);\n\t}\n\n}\n```\n\n우리의 기대와 달리, 트랜잭션이 `userRepository.save()` 와 `userDetailRepository.save()` 에 각각 적용된다.\n어느 하나라도 실패가 된다면, 다른 쿼리도 `Rollback`  이 되어야 하지만, 실패해도 롤백이 이루어지지 않는다.\n\n![개별적으로 트랜잭션이 적용되는 모습](double-tx-image.png)\n\nTypeORM 설정에서 `logging` 옵션을 `true` 로 두고 `데이터베이스 로그` 를 확인해보면 트랜잭션이 각각 분리되어 전송되는 것을 확인할 수 있다. \n\n만약 둘 중 하나가 실패한다면? 정상적으로 롤백이 이루어질까? 일부러 둘 중 하나의 로직이 실패하게 유도하고 결과를 지켜보자.\n\n![User 테이블은 데이터 저장, UserDetail 테이블은 Rollback](./no-rollback-result.png)\n\n예상했던 결과처럼 `User` 테이블에는 데이터가 성공적으로 삽입되었고, 에러가 발생한 `UserDetail` 데이터는 삽입되지 않았다.\n\n## 트랜잭션 적용하기\n---\n지금까지 트랜잭션이 정상적으로 적용되지 않는다는 것을 알 수 있었다. 이제 NestJS과 TypeORM에서 지원하는 트랜잭션 적용 방법을 알아보도록 하겠다.\n\n```typescript\n@Injectable()\nexport class UserService {\n\tconstructor(private dataSource: DataSource) {}\n\n\tasync createUser(request: UserCreateRequest) {\n\t\tconst queryRunner = this.dataSource.createQueryRunner();\n\t\n\t\tawait queryRunner.connect();\n\t\tawait queryRunner.startTransaction(); // TRANSACTION START\n\n\t\ttry {\n\t\t\tconst user = queryRunner.manager.create(User, request);\n\t\t\tawait queryRunner.manager.save(user); // User 저장\n\t\t\t\n\t\t\tconst detail = queryRunner.manager.create(UserDetail, request);\n\t\t\tawait queryRunner.manager.save(detail); // UserDetail 저장\n\t\t\t\n\t\t\tawait queryRunner.commitTransaction(); // COMMIT\n\t\t} catch (err) {\n\t\t\tawait queryRunner.rollbackTransaction();\n      throw err;\n\t\t} finally {\n\t\t\tawait queryRunner.release();\n\t\t}\n\t\t\n\t}\n}\n```\n\n**심히 당황스럽다.**\n\n핵심 로직은 엔티티를 생성하고, 저장하는 `4줄` 밖에 되지 않는다. 하지만 트랜잭션 로직 때문에 간단한 `createUser()` 함수가 거대해졌다. 혹시라도 함수의 내용이 방대해지거나, 분리가 필요하면 트랜잭션의 추적도 쉽지 않을 것이다.\n\n> **DataSource를 의존성 주입을 받을 수 있는 이유**\n>\n> `@nestjs/typeorm` 의존성을 통해 `TypeOrmModule` 을 import 하면 내부에서 `DataSource` , `EntityManager` 등을 기본적으로 `Provider`로 추가한다. \n> <br> 실제 코드는 [@nestjs/typeorm typeorm-core-module.ts](https://github.com/nestjs/typeorm/blob/master/lib/typeorm-core.module.ts) 에서 확인할 수 있다.\n\n그럼 다음과 같은 코드는 작동하지 않을까? \n\n```ts\n@Injectable()\nexport class UserService {\n\n    constructor(\n        private readonly em: EntityManager,\n        private readonly userRepository: UserRepository,\n    ) {}\n\n    async createUser(userCreateRequest: UserCreateRequest): Promise<void> {\n        await this.em.transaction(async (manager) => {\n            await this.userRepository.save(userCreateRequest);\n        })\n    }\n\n}\n```\n\n![트랜잭션이 중첩되는 모습](nested-tx-image.png)\n\n\n결과는 기대했던 결과와는 달리 `트랜잭션`이 중첩되어 실행된다.\n\n결론부터 말하자면, `UserService의 EntityManager` 와 `UserRepository의 EntityManager`가 서로 다른 참조를 하고 있다는 것이다.  \n\n`UserService` 에 주입된 `EntityManager`의 `transaction`을 통해 생성된 `EntityManager` 와 `UserRepository` 에서 참조하는 `EntityManager` 는 같지 않다. \n\n이는 [TypeORM 공식 Github]() 코드를 통해 확인 할 수 있다.\n\n```ts\n/* typeorm/src/entity-manager/EntityManager.ts  */\n\nasync transaction<T>(...) {\n\t// 만약 해당 클래스에 QueryRunner가 이미 할당되어있다면, EntityManager가\n\t// 이미 Single Connection을 생성한 것 입니다.\n\t// 만약 정의되지 않은 경우, 모든 작업을 실행할 새로운 Single Connection을 생성합니다.\n\tconst queryRunner =\n\t\tthis.queryRunner || this.connection.createQueryRunner()\n}\n```\n\n이 코드는 공식 `TypeORM`의 `EntityManager.ts` 의 코드 중 `transaction()` 함수 중 일부를 발췌한 것이다. 해당 코드는 쿼리 시에 사용할 `QueryRunner` 를 정의하는데, 이미 사용하고 있는 `QueryRunner` 가 없다면 새로운 `QueryRunner` 를 생성한다. \n\n`this.connection.createQueryRunner()` 함수를 통해 새로운 `QueryRunner` 를 생성하게 되는데 이는 `DataSource.ts` 의 `createQueryRunner()` 와 같다.\n\n```typescript\n/* typeorm/src/data-source/DataSource.ts */\n\ncreateQueryRunner(mode: ReplicationMode = \"master\"): QueryRunner {\n\tconst queryRunner = this.driver.createQueryRunner(mode)\n\tconst manager = this.createEntityManager(queryRunner)\n\tObject.assign(queryRunner, { manager: manager })\n\treturn queryRunner\n}\n\ncreateEntityManager(queryRunner?: QueryRunner): EntityManager {\n\treturn new EntityManagerFactory().create(this, queryRunner)\n}\n\n...\n```\n\n실질적인 `QueryRunner` 는 각 `Database Driver` 를 구현한 구현체에 맡기고, `EntityManager` 는 `DataSource.ts` 에 정의된 `createEntityManager()` 함수를 통해 생성하여, `QueryRunner` 의 `manager` 에 저장한다. \n\n그렇기 때문에 `UserService` 에 주입된 `EntityManager` 와 `UserRepository에서` 참조하는 `EntityManager` 가 서로 다른 객체를 참조하고 있는 것이다.\n\n그럼 어떻게 `EntityManager.transaction()` 의 인자로 주어진 함수에서 같은 `EntityManager` 를 사용할 수 있을까? \n\n이 내용은 앞서 이야기 했던 `AOP` 라는 주제와 함꼐 직접 `@Transactional` 을 구현하여, 적용해보는 내용을 [다음 글]() 에 소개하도록 하겠다."},{"excerpt":"어느 날, 마우스 휠 Up, Down을 통해 IntelliJ Editor의 Font Size 조절이 갑자기 되지 않았다.  옵션을 건드려봐도, Mac 자체에서 지원하는 Zoom이 될 뿐, Editor의 Font Size가 변경되지는 않았다. 해결방법 1. 손쉬운 사용 설정 켜져있는지 확인 나의 경우  에서  에 가 매핑되어 있었다.  이러한 경우  옵션을…","fields":{"slug":"/intellij-zoom-issue/"},"frontmatter":{"date":"May 15, 2025","title":"IntelliJ Mouse Wheel Zoom 이슈","tags":["이슈","개발환경"]},"rawMarkdownBody":"어느 날, 마우스 휠 Up, Down을 통해 IntelliJ Editor의 Font Size 조절이 갑자기 되지 않았다.\n\n`IntelliJ IDEA -> Settings -> Editor -> General -> Change font size in Command + Mouse Wheel in` 옵션을 건드려봐도, Mac 자체에서 지원하는 Zoom이 될 뿐, Editor의 Font Size가 변경되지는 않았다.\n## 해결방법\n### 1. 손쉬운 사용 설정 켜져있는지 확인\n나의 경우 `손쉬운 사용 -> 확대/축소` 에서 `스크롤 제스처를 위한 보조 키` 에 `Command(⌘)`가 매핑되어 있었다.\n\n![스크롤 제스처를 위한 보조 키에 Command(⌘)가 설정되어 있다.](image.png)\n\n이러한 경우 `스크롤 제스처를 위한 보조 키` 옵션을 다른 키로 설정하여 주고, IntelliJ의 `IntelliJ IDEA -> Settings -> Editor -> General -> Change font size in Command + Mouse Wheel in` 옵션이 켜져있으면 정상적으로 마우스 휠을 통해 Font Size 조절이 가능하다.\n\n### 2. Keymap\n`스크롤 제스처를 위한 보조 키` 옵션을 변경하지 않고 해결하는 방법은 바로 IntelliJ의 `Keymap`을 활용하는 것이다. \n\n1. `IntelliJ IDEA` -> `Settings` -> `Keymap`\n2. `Increase Font Size` 검색 <br>\n  a. `Add ... Shortcut` 선택 후 단축키 입력\n3. `Decrease Font Size` 검색 <br>\n  a. `Add ... Shortcut` 선택 후 단축키 입력\n\n![Keymap - Increase Font Size 검색 화면](image-1.png)\n\n해당 설정은 `스크롤 제스처를 위한 보조 키` 옵션에 `Command(⌘)`가 설정되어 있고, 바꾸고 싶지 않을 때 사용할 수 있는 설정이다. 단축키 설정 시, `Command(⌘)`가 들어가지 않게 설정하여야 유효하게 사용할 수 있다."}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}